# Vite를 사용하는 이유

### 문제점

브라우저에서 ESM(ES Modules)를 지원하기 전까지는 JavaScript 모듈화를 네이티브 레벨에서 진행했어야 했습니다. 그래서 개발자들은 번들링(Bundling) 이라는 우회적인 방법을 사용할 수 밖에 없었습니다. 

예 - (Webpack, Rollup , Parcel)

<aside>
💡 **ES Modules**  **(ESM)** 이란?
- ES6에 도입된 모듈 시스템, 
**번들링** 이란? 
- 모듈화된 source code를 브라우저에서 실행할 수 있는 파일로 한데 묶어주는 작업을 뜻합니다.
**모듈화** 란?
- 소프트웨어의 성능을 향상시키거나 시스템의 디버깅, 시험, 통합 및 수정을 용이하도록 하는 소프트웨어 설계 기법

</aside>

하지만 애플리케이션이 점점 발전하면서 처리해야 하는 JavaScript 모듈의 개수도 극적으로 증가하고 있습니다. 대규모 프로젝트에서는 수천개의 모듈이 존재하는 경우도 있고, 이러한 상황에서 JavaScript 기반의 도구는 **성능 병목 현상**이 발생하게 됩니다.

이는 서버를 가동하는데 비합리적으로 오랜 시간을 기다려야 한다거나 **HMR**을 사용하더라도 변경된 파일이 적용될 때 까지 수 초 이상 소요되곤 했습니다.

이런 상황은 개발자들의 생산성에 영향을 미칩니다.

브라우저에서 지원하는 ES Modules(ESM) 및 네이티브 언어로 작성된 JavaScript 도구 등을 활용해 문제해결을 하는것이 Vite의 방향성입니다.

<aside>
💡 **HMR (Hot Module Replacement)** 란?
- 브라우저를 새로 고치지 않아도 웹팩으로 빌드한 결과물이 웹 애플리케이션에 실시간으로 반영될 수 있게 도와주는 설정입니다.  브라우저 새로 고침을 위한 LiveReload 대신에 사용할 수 있으며 웹팩 데브 서버와 함께 사용할 수도 있습니다.
- 앱을 종료하지 않고 갱신된 파일만 교체하는 방식 , 다만 마찬가지로 앱 사이즈가 커질수록 갱신에 필요한 시간이 증가합니다.

</aside>



### 긴 서버 구동 시간

**Cold-Start** 방식으로 개발 서버를 구동할 때, 번들러 기반의 도구의 경우 애플리케이션 내 모든 source code에 대해 크롤링 및 빌드 작업을 마쳐야 실제 페이지를 제공할 수 있습니다.

<aside>
💡 **Cold-Start** 란?
- 최초로 실행되어 이전에 캐싱한 데이터가 없는 경우를 의미합니다

</aside>

VIte 는 이문제를 **Dependencies** 그리고 **Source Code** 두 가지 카테고리로 나누어 개발 서버를 시작하여 해결하고 있습니다.

- **Dependencies** : 개발 시 그 내용이 바뀌지 않을 일반적인(Plain) JavaScript 소스코드입니다.       기존 번들러로는 컴포넌트 라이브러리와 같이 몇 백개의 JavaScript 모듈을 갖고 있는 매우 큰 Dependencies에 대한 번들링과장이 매우 비효율적이였고 많은 시간이 필요했습니다.                 Vite의 사전 번들링 기능은 EsBuild를 사용하고 있습니다. Go로 박성된 Esbuild는 Webpack과 Parcel 과 같은 기존의 번들러 대비 10-100배 빠른 번들링 속도를 보였습니다.

- **Source Code** : JSX, CSS 또는 Vue/Svelte 컴포넌트와 같이 컴파일리이 필요하고, 수정 또한 매우 잦은 **Non-plain JavaScript** 소스코드는 어떻게 할까요? ( 이들 역시 특정 시점에서 모두 불러올 필요는 없습니다.)  

Vite는 **[Native ESM](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Modules)**을 이용해 소스 코드를 제공하도록 하고 있습니다. 다시 말해, 브라우저가 곧 번들러 입니다. vite는 브러우저의 판단 아래 특정 모듈에 대한 소스 코드를 요청하면 이를 전달할 뿐입니다. 따라서 조건부 동적 Import 이후의 코드는 현재 화면에서 실제로 사용이 되어야 처리가 됩니다.

### 느렸던 소스 코드 갱신

기존의 번들러 기반으로 개발을 진핼할 때, 소스 코드를 업데이트 하게 되면 번들링 과정을 다시 거쳐야 했습니다. 따라서 서비스가 커질수록 소스코드의 갱신시간 또한 증가할 수 밖에 없습니다.

일부 번들러의 경우 메모리 상에서 이를 진행하여 실제로 갱신에 영향을 받는 파일들만 새로 번들링하게끔 했으나, 결국 이 방법도 처음에는 모든 파일에 대한 번들링을 시도해야 합니다.  “모든 파일”을 번들링 하고 이를 다시 웹페이지에서 불러오는 것은 굉장히 비효율적 입니다.

이런 이슈를 해결하고자 HMR(Hot Module Replacement)라는 대안이 나왔지만, 이 역시 명확한 해답이 아닙니다.  마찬가지로 앱 사이즈가 커질수록 갱신에 필요한 시간이 증가하기 떄문이죠.

**Vite 는 번들러가 아닌 ESM을 이용해서 HMR을 지원합니다.**  어떤 모듈이 수정되면 vite는 그저 수정된 모듈과 관련된 부분만을 교체할 뿐이고, 브라우저에서 해당 모듈을 요청하면 교체된 모듈을 전달할 뿐입니다. 전 과정에서 완벽하게 ESM을 이용하기에, 앱 사이즈가 커져도 HMR을 포함한 갱신 시간에는 영향을 끼치지 않습니다.

또한 Vite는 HTTP 헤더를 이용해 퍼포먼스를 한단계 높였습니다. 필요에 따라 소스 코드는 
`304 Not Modified` 로, 디펜던시는 `Cache-Control: max-age=31536000,immutable` 을 이용해 캐시되도록 함으로써, 한번의 요청이 덜하도록 합니다.

---

### 배포 시 번들링 과정이 필요한 이유

이제 기본적으로 ESM이 대부분의 환경에서 지원되지만, 프로덕션에서 번들 되지 않은 ESM을 가져오는 것은 중첩된 Import로 인한 추가 네트워크 통신으로 인해 여전히 비효율적입니다.(HTTP/2 를 사용하더라도). production env에서 최적의 loading 성능을 얻으려면 트리 셰이킹, 지연로딩 및 청크 파일 분할( 더 나은 캐싱을 위해)을 이용하여 번들링 하는 것이 더 좋습니다.

개발 서버와 프로덕션 빌드 간에 최적의 출력과 동작 일관성을 보장하는 것은 쉽지 않습니다. 이것이 바로 VIte가 미리 설정된 [**Build command**](https://vitejs-kr.github.io/guide/build.html)를 이용하고, [**빌드 퍼포먼스 최적화**](https://vitejs-kr.github.io/guide/features.html#build-optimizations)를 진행하는 이유입니다.

---

### 왜 번들링 시에는 Esbuild를 사용하지 않나요?

`Esbuild` 는 극단적이게 빠른 속도로 번들링이가능하다는 장점이 있지만, 번들리에 필수적으로 요구되는 기능인 코드 분할(Code-splitting) 및 CSS와 관련된 처리가 아직 미비합니다. VIte에서 사용중인 Rollup은 이에 대해 조금 더 검증되었고 유연한 처리가 가능하게끔 구현되어 있기에 현재로서는 이를 사용하고 있으며, 향후 `Esbuild` 가 안정화 되었을 떄 어떤 프로덕션 번들링 도구가 적절할 것인지 논의 될겁니다.

⇒ 운영에는 Rollup 사용 중